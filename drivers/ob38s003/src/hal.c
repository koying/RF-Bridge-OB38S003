/*
 *
 *  Ported on: 02.16.2023
 *      Author: Jonathan Armstrong
 */

#include "hal.h"
#include "OB38S003.h"


// pg. 3 of OB38S003 datasheet
// high speed architecture of 1 clock/machine cycle runs up to 16MHz.
void set_clock_1t_mode(void)
{
    // default is 2T mode
    // ITS = 000 or 1T mode
    CKCON = 0x00;
}

void set_clock_6t_mode(void)
{
    // ITS = 101 or 6T mode
    CKCON = 0x50;
}

// pg. 44 - once the watchdog is started it cannot be stopped
void enable_watchdog(void)
{
    // changes WDTC from read only
    TAKEY = 0x55;
    TAKEY = 0xAA;
    TAKEY = 0x5A;
    
    // sets WDTE bit
    WDTC |= 0x20;
}

void refresh_watchdog(void)
{
    // pg. 46 - Clear WDT timer to 0.
    WDTK = 0x55;
}

void init_port_pins(void)
{
    // buzzer push pull
    P0M1 &= ~0x01;
    P0M0 |=  0x01;
    
    // uart tx push pull
    //P1M1 &= ~0x01;
    //P1M0 |=  0x01;
    
    // radio incoming input only
    //P1M1 |=  0x40;
    //P1M0 &= ~0x40;
	
	// software uart (transmit by reset pin)
	// default should be quasi output
	//P1M1 &= ~0x20;
	//P1M0 &= ~0x20;
    
    // rf sleep/wake push pull
    // see sonoffr22_pins.h - pin attached to upper leg of resistor divider
    P1M1 &= ~0x80;
    P1M0 |=  0x80;
    
    // led push pull
    P3M1 &= ~0x01;
    P3M0 |=  0x01;
    
}


void init_uart(void)
{
    // BRGS = 1 so uart baud rate generator uses SREL (instead of timer 1)
    AUX |= 0x80;
    
    // mode 1, no parity bit SM0 = 0 and SM2 = 0 by default
    SM1 = 1;
    
    // see formula below with SMOD = 1
    PCON |= 0x80;
    
    // SRELPS0 = 1;
    PFCON |= 0x10;
    
    // pg. 43, sec. 8.4.1.2
    // baud rate = (2^SMOD x Fosc) / ((32 or 64) * (2^10 - SREL))
    // SRELPS[1:0] = 00 divisor is 64, 01 divisor is 32
    // (2^1 * 16000000)/(32*(2^10 - 920)) = 9615
    // FIXME: consider computing with macro dependent on clock frequency
    //SRELH = 0x03;
    //SRELL = 0x98;
    
    // 19200
    SRELH = 0x03;
    SRELL = 0xcc;
}



void init_serial_interrupt(void)
{
    // enable serial interrupt
    ES = 1;
}

void enable_capture_interrupt(void)
{
    CCCON |= 0x20;
}

void disable_capture_interrupt(void)
{
    CCCON &= ~0x20;
}

void init_timer0(const uint16_t value)
{
    // 16-bit mode
    TMOD |= 0x01;
    
    // FIXME: T0PS 0x01 prescaler Fosc
    // FIXME: this would not necessarily clear upper bit, so bad HAL
    PFCON |= 0x01;
    
    // one millisecond to overflow
    //TH0 = 0xc1;
    //TL0 = 0x7f;
    TH0 = (value >> 8) & 0xff;
    TL0 = value & 0xff;
    
    // enable timer0
    TR0 = true;
}

void init_timer1(const uint16_t value)
{
    // 16-bit mode
    TMOD |= 0x10;
    
    // T1PS prescaler Fosc
    // b01 = FOCS
    PFCON |= 0x04;
    
    // ten microseconds to overflow
    //TH1 = 0xff;
    //TL1 = 0x5f;
    TH1 = (value >> 8) & 0xff;
    TL1 = value & 0xff;
    
    // enable timer1
    TR1 = true;
}

//================================================================================
// datasheet states that using timer2 in capture mode is similar to programmable counter array (PCA) on other microcontrollers
//================================================================================
void init_timer2_capture(void)
{
    // capture on both rising and falling edge at pin CC1
    //(i.e., P1.6 or RDATA which is input from D0 of radio)
    CCEN  = 0x60;
    
    // time 2 input frequency from prescaler
    // timer 2 mode 0 auto reload (generated by a timer 2 overflow)
    // timer 2 is clocked with 1/4 (0x51) or 1/24 (0xD1) of the oscillator frequency (prescaler select bit)
    // (e.g., 0.25 microseconds per count)
    T2CON = 0xD1;
}

bool global_interrupts_are_enabled(void)
{
    return EA;
}

void load_timer0(const uint16_t value)
{
    TH0 = (value >> 8) & 0xff;
    TL0 = value & 0xff;
}

void load_timer1(const uint16_t value)
{
    TH1 = (value >> 8) & 0xff;
    TL1 = value & 0xff;
}

unsigned char get_timer2_low(void)
{
    return CCL1;
}

unsigned char get_timer2_high(void)
{
    return CCH1;
}

void clear_ccp1_flag(void)
{
    CCCON &= ~0x02;
}

unsigned char get_stack_pointer(void)
{
    return SP;
}